import json

import openai
import ast
import io
import logging
import re
import sys
import uuid
from contextlib import redirect_stdout
from typing import List, Optional, Union
import astor
import pandas as pd
from pathlib import Path
import pyecharts

ABS_PATH = Path(__file__).parent.absolute()
sys.path.append(str(ABS_PATH))

from utils import utils
from prompts import Prompts
from configs import configs as cfg
from configs.constants import WHITELISTED_BUILTINS

class AIAnalyse:

    def __init__(self, llm=None, save_charts=False):
        self._llm = llm
        self._save_charts = save_charts

    def run(self, data_frame: pd.DataFrame, prompt: str, show_code: Optional[bool] = False):
        df_head = data_frame.head()
        num_rows, num_columns = data_frame.shape
        prompts = Prompts(num_rows=num_rows, num_cols=num_columns, df_head=df_head)
        highlight_prompt = prompts.generate_highlight_prompt()
        print(highlight_prompt)
        highlight_response = utils.gpt(highlight_prompt)
        highlight_list = utils.str_to_list_by(highlight_response, split="\n")
        for each_highlight in highlight_list:
            code_prompt = prompts.generate_python_code_prompt_by_suggestion(each_highlight)
            code_response = utils.gpt(code_prompt)
            code = self._get_code(code_response)
            self.run_code(code)

        if show_code:
            print(code)
        if self._save_charts:
            code = utils.save_chart(code, folder_name="charts")

    def __call__(self, data_frame: pd.DataFrame, prompt: str, show_code: Optional[bool] = False):
        return self.run(data_frame=data_frame, prompt=prompt, show_code=show_code)

    def _clean_code(self, code: str) -> str:
        """
        A method to clean the code to prevent malicious code execution
        Args:
            code(str): A python code

        Returns (str): Returns a Clean Code String

        """

        tree = ast.parse(code)

        new_body = [
            node
            for node in tree.body
            if not (self._is_unsafe_import(node) or self._is_df_overwrite(node))
        ]

        new_tree = ast.Module(body=new_body)
        return astor.to_source(new_tree).strip()

    def run_code(self, code: str, data_frame: pd.DataFrame, use_error_correction_framework: bool = True) -> str:
        """
        A method to execute the python code generated by LLMs to answer the question about the
        input dataframe. Run the code in the current context and return the result.
        Args:
            code (str): A python code to execute
            data_frame (pd.DataFrame): A full Pandas DataFrame
            use_error_correction_framework (bool): Turn on Error Correction mechanism.
            Default to True

        Returns:

        """
        # Add save chart code
        if self._save_charts:
            code = add_save_chart(code)

        code_to_run = self._clean_code(code)
        self.last_run_code = code_to_run
        utils.log(
            f"""
            Code running:
            ```
            {code_to_run}
            ```"""
        )

        environment: dict = {
            "pd": pd,
            "json": json,
            "pyecharts": pyecharts,
            "df": data_frame,
            "__builtins__": {
                **{builtin: __builtins__[builtin] for builtin in WHITELISTED_BUILTINS},
            },
        }

        # Redirect standard output to a StringIO buffer
        with redirect_stdout(io.StringIO()) as output:
            count = 0
            while count < self._max_retries:
                try:
                    # Execute the code
                    exec(code_to_run, environment)
                    code = code_to_run
                    break
                except Exception as e:  # pylint: disable=W0718 disable=C0103
                    if not use_error_correction_framework:
                        raise e

                    count += 1

                    error_correcting_instruction = CorrectErrorPrompt(
                        code=code,
                        error_returned=e,
                        question=self._original_instructions["question"],
                        df_head=self._original_instructions["df_head"],
                        num_rows=self._original_instructions["num_rows"],
                        num_columns=self._original_instructions["num_columns"],
                        rows_to_display=self._original_instructions[
                            "rows_to_display"
                        ],
                    )

                    code_to_run = self._llm.generate_code(
                        error_correcting_instruction, ""
                    )

        captured_output = output.getvalue()

        # Evaluate the last line and return its value or the captured output
        lines = code.strip().split("\n")
        last_line = lines[-1].strip()

        match = re.match(r"^print\((.*)\)$", last_line)
        if match:
            last_line = match.group(1)

        try:
            return eval(last_line, environment)
        except Exception:  # pylint: disable=W0718
            return captured_output

    def _get_code(self, gpt_response: str, separator: str = "```") -> str:
        code = gpt_response
        match = re.search(
            rf"{cfg.START_CODE_TAG}(.*)({cfg.END_CODE_TAG}|{cfg.END_CODE_TAG.replace('<', '</')})",
            code,
            re.DOTALL,
        )
        if match:
            code = match.group(1).strip()
        if len(code.split(separator)) > 1:
            code = code.split(separator)[1]
        code = self._polish_code(code)
        if not self._is_python_code(code):
            raise utils.log("Invalid Python Code")
        return code

    def _polish_code(self, code: str) -> str:
        """
        Polish the code by removing the leading "python" or "py",  \
        removing the imports and removing trailing spaces and new lines.

        Args:
            code (str): Code

        Returns:
            str: Polished code
        """
        if re.match(r"^(python|py)", code):
            code = re.sub(r"^(python|py)", "", code)
        if re.match(r"^`.*`$", code):
            code = re.sub(r"^`(.*)`$", r"\1", code)
        code = code.strip()
        return code

    def _is_python_code(self, string):
        """
        Return True if it is valid python code.
        Args:
            string (str):

        Returns (bool): True if Python Code otherwise False

        """
        try:
            ast.parse(string)
            return True
        except SyntaxError:
            return False


if __name__ == '__main__':
    client = AIAnalyse()
    df = pd.read_csv("test/data/as_macro_cnbs.csv")
    client.run(data_frame=df, prompt="")



